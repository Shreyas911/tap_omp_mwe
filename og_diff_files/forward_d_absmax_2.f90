!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 14 Mar 2025 11:54
!
MODULE FORWARD_TGT
  IMPLICIT NONE

CONTAINS
!  Differentiation of forward_problem in forward (tangent) mode (with options OpenMP):
!   variations   of useful results: v
!   with respect to varying inputs: xx
!   RW status of diff variables: v:out xx:in
  SUBROUTINE FORWARD_PROBLEM_D(xx, xxd, v, vd)
    IMPLICIT NONE
    INTEGER :: i
    REAL*8, DIMENSION(10000), INTENT(IN) :: xx
    REAL*8, DIMENSION(10000), INTENT(IN) :: xxd
    REAL*8, DIMENSION(10000) :: vi
    REAL*8, DIMENSION(10000) :: vid
    REAL*8, INTENT(OUT) :: v
    REAL*8, INTENT(OUT) :: vd
    REAL*8 :: tap_temp_abs1, tap_temp_abs2, tap_temp_abs3, tap_temp_max1, tap_temp_max2
    REAL*8 :: tap_temp_abs1d, tap_temp_abs2d, tap_temp_abs3d, tap_temp_max1d, tap_temp_max2d
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC SUM
    vid = 0.0_8
!$OMP PARALLEL DO DEFAULT(shared), PRIVATE(i, tap_temp_abs1, tap_temp_abs2, tap_temp_abs3, tap_temp_max1, tap_temp_max2), PRIVATE(tap_temp_abs1d, tap_temp_abs2d, tap_temp_abs3d, tap_temp_max1d, tap_temp_max2d), SCHEDULE(static)
    DO i=1,10000
      IF (xx(i)**2 + xx(i)**3 .GE. 0) THEN
! sin function
        vid(i) = COS(xx(i))*xxd(i)
        vi(i) = SIN(xx(i))
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs1d = xxd(i)
          tap_temp_abs1 = xx(i)
        ELSE
          tap_temp_abs1d = -xxd(i)
          tap_temp_abs1 = -xx(i)
        END IF
        vid(i) = vid(i) + tap_temp_abs1d
        vi(i) = vi(i) + tap_temp_abs1
        IF (xx(i) .LT. 1.0) THEN
          tap_temp_max1 = 1.0
          tap_temp_max1d = 0.0_8
        ELSE
          tap_temp_max1d = xxd(i)
          tap_temp_max1 = xx(i)
        END IF
        vid(i) = vid(i) + tap_temp_max1d
        vi(i) = vi(i) + tap_temp_max1
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs2d = xxd(i)
          tap_temp_abs2 = xx(i)
        ELSE
          tap_temp_abs2d = -xxd(i)
          tap_temp_abs2 = -xx(i)
        END IF
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs3d = xxd(i)
          tap_temp_abs3 = xx(i)
        ELSE
          tap_temp_abs3d = -xxd(i)
          tap_temp_abs3 = -xx(i)
        END IF
        IF (tap_temp_abs3 .LT. 1.0) THEN
          tap_temp_max2 = 1.0
          tap_temp_max2d = 0.0_8
        ELSE
          tap_temp_max2d = tap_temp_abs3d
          tap_temp_max2 = tap_temp_abs3
        END IF
        vid(i) = vid(i) + (tap_temp_abs2d-tap_temp_abs2*tap_temp_max2d/tap_temp_max2)/tap_temp_max2
        vi(i) = vi(i) + tap_temp_abs2/tap_temp_max2
      END IF
    END DO
    vd = SUM(vid)
    v = SUM(vi)
  END SUBROUTINE FORWARD_PROBLEM_D

  SUBROUTINE FORWARD_PROBLEM(xx, v)
    IMPLICIT NONE
    INTEGER :: i
    REAL*8, DIMENSION(10000), INTENT(IN) :: xx
    REAL*8, DIMENSION(10000) :: vi
    REAL*8, INTENT(OUT) :: v
    REAL*8 :: tap_temp_abs1, tap_temp_abs2, tap_temp_abs3, tap_temp_max1, tap_temp_max2
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC SUM
!$OMP PARALLEL DO DEFAULT(shared), PRIVATE(i, tap_temp_abs1, tap_temp_abs2, tap_temp_abs3, tap_temp_max1, tap_temp_max2), SCHEDULE(static)
    DO i=1,10000
      IF (xx(i)**2 + xx(i)**3 .GE. 0) THEN
! sin function
        vi(i) = SIN(xx(i))
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs1 = xx(i)
        ELSE
          tap_temp_abs1 = -xx(i)
        END IF
        vi(i) = vi(i) + tap_temp_abs1
        IF (xx(i) .LT. 1.0) THEN
          tap_temp_max1 = 1.0
        ELSE
          tap_temp_max1 = xx(i)
        END IF
        vi(i) = vi(i) + tap_temp_max1
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs2 = xx(i)
        ELSE
          tap_temp_abs2 = -xx(i)
        END IF
        IF (xx(i) .GE. 0.) THEN
          tap_temp_abs3 = xx(i)
        ELSE
          tap_temp_abs3 = -xx(i)
        END IF
        IF (tap_temp_abs3 .LT. 1.0) THEN
          tap_temp_max2 = 1.0
        ELSE
          tap_temp_max2 = tap_temp_abs3
        END IF
        vi(i) = vi(i) + tap_temp_abs2/tap_temp_max2
      END IF
    END DO
    v = SUM(vi)
  END SUBROUTINE FORWARD_PROBLEM

END MODULE FORWARD_TGT

